linux设备3种类型
1字符设备：必须以串行顺序依次进行访问的设备
2块设备：可以按任意顺序进行访问，以块为单位进行操作
12都使用文件系统接口编程open，close，read，write
3网络设备：面向数据包的接收和发送，不适用文件系统接口编程，使用socket

块设备的访问有两种方式
1使用原始设备访问如/dev/sdb
2使用文件系统虚拟出的文件名称访问

冯诺依曼结构
存储器的程序和数据在一起，共用总线（地址和数据）
哈佛结构
存储器的程序和数据分开，独立使用总线（地址和数据）
改进的模型程序和数据存储器分开，但是复用总线（地址和数据）

通用处理器GPP
数字信号处理器DSP
硬件乘法器
卷积，数字滤波，FFT，矩阵运算
浮点DSP硬件浮点运算
专用处理器ASP及ASIC

CFI
SRAM NOR
片上执行
NAND只可块操作，专用接口

对于NOR，NAND等提供了MTD子系统，其上运行的YFSS2，JFFS3，UBIFS等具备擦出和负载均衡能力的文件系统

外设接口
RS232 RS485
I2C SPI CAN
USB SDIO LAN
EMMC I3C MIPI

linux2.6内核
调度器CFS算法EDF算法
内核抢占，线程模型NPTL
虚拟内存 反向映射
文件系统 btrfs
总线、设备、驱动模型

驱动drivers与arch独立，kernel fs ipc net等与硬件剥离
进程调度 内存管理 VFS net IPC
进程调度 CFS算法EDF算法
内存管理buddy算法slab flusher kswapd
VFS 为各个不同文件系统封装为统一接口，还有利用net的NFS，利用mm的ramdisk
NET
IPC 信号量，共享内存，消息队列，管道，UNIX域套接字

早期bootloader以ATAG格式形式封装启动信息，把其地址放入r2寄存器，linux支持设备树后，bootloader把dtb地址放入r2，可以通过配置把dtb和zImage绑定，r2不需要放dtb地址了
bootrom--bootloader--linux--init运行并生成进程树
arm-linux-guneabihf-gcc使用硬件浮点FPU处理浮点数比arm-linux-guneabi-gcc编译的程序处理浮点数运算的性能好得多

驱动模块
insmod modprobe加载模块，rmmod卸载模块
驱动程序中使用request_module(module_name)加载模块
声明时加_init的函数和声明时加_initdata的变量将在初始化完成后释放内存空间
模块卸载函数和变量中加_exit _exitdata表示如果模块直接编译进内核时，这些变量和函数将被忽略，因为不会使用卸载函数
module_param()用于从insmod modprobe参数中获取参数，当编译进内核时，可以从bootargs获取
/proc/kallsyms存放内核符号表及其地址，导出的符号可以被其他模块使用，声明一下即可EXPORT_SYMBOL,EXPORT_SYMBOL_GPL到处的符号表不能被非GPL的模块引用
MODULE_LISENCE,为了使用GPL的符号表，非GPL的模块经常把GPL的符号表封装一层使用EXPORT_SYMBOL导出
作者MODULE_AUTHOR，描述MODULE_DESCRIPTION，版本MODULE_VERSION，设备表MODULE_DEVICE_TABLE，别名MODULE_ALIAS
SMP和PREEMPT
模块计数用于管理模块是否被使用，被使用时无法卸载模块
linux文件操作creat umask open read write lseek close
c库文件操作fopen fgetc fputc fgets fputs fprintf fscanf fread fwrite fgetpos fsetpos fseek fclose
fread如果返回值不等与字段数，可能时出错或者文件末尾，需要调用feof或ferror查看
VFS与应用之间的接口是以上系统调用，与内核接口是file_operations
目录/proc目录存放进程及内核信息，这个目录并不是真正的文件，他存在于内存中，/sys目录存放sysfs，虚拟的，linux设备驱动模型中的总线驱动和设备都有节点，总线设备类
文件file结构体和inode结构体
linux2.6以后udev取代devfs
注册和注销字符设备register_chrdev,unregister_chrdev
linux设计的一个基本观点是机制和策略分离，机制是做事情的步骤方法，是固定的，策略是每个步骤的具体实现，是不固定的，因此linux内核中不应实现策略
udev完全在用户态工作，发送的事件uevent
总线bus_type,驱动device_driver,设备device结构体
设备和驱动都依附于总线，因此设备和驱动结构体中都有总线的实例，设备和驱动分离，通过总线match函数检测到匹配的设备和驱动时，才执行驱动的probe函数，
总线有platform，pci，i2c，usb等，总线设备驱动最终落实在sysfs，attribute落实为sysfs中的一个文件
udev动态建立删除设备文件，内核检测到设备后，会使用netlink发送uevent，udev通过内核发送的内容进行匹配，例如插入u盘，udev规则文件定义新设备处理规则
udevadm info -a -p /sys/device/platform/serial8250/tty/ttyS0
udev的轻量级版本mdev

字符设备驱动：cdev结构体
cdev_init建立设备和file_operation产生联系
cdev_alloc开辟cdev空间
cdev_add,cdev_dev设备添加和删除
register_chrdev_region申请设备号
alloc_chrdev_region申请设备号，设备号起始地址未知
unregister_chrdev_region释放设备号

file_operation结构体
llseek read write（read write返回0表示EOF）
unlocked_ioctl和用户空间fcntl和ioctl对应
mmap将设备内存映射到进程的虚拟地址空间，帧缓冲驱动中使用其直接修改显示内容
open release
poll和用户空间的poll和select对应
aio_read aio_write异步读写，对应用户空间SYS_io_setup,SYS_io_submit,SYS_io_getevents,SYS_io_destroy
用户空间不能访问内核空间内存，使用copy_from_user,copy_to_user转换
内核空间可以访问用户空间内存，使用access_ok检查是否是用户空间内存，如果不检查，入侵者可以传入一个内核空间地址，让驱动给其填充数据


