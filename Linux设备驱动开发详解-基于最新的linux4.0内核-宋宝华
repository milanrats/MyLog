linux设备3种类型
1字符设备：必须以串行顺序依次进行访问的设备
2块设备：可以按任意顺序进行访问，以块为单位进行操作
12都使用文件系统接口编程open，close，read，write
3网络设备：面向数据包的接收和发送，不适用文件系统接口编程，使用socket

块设备的访问有两种方式
1使用原始设备访问如/dev/sdb
2使用文件系统虚拟出的文件名称访问

冯诺依曼结构
存储器的程序和数据在一起，共用总线（地址和数据）
哈佛结构
存储器的程序和数据分开，独立使用总线（地址和数据）
改进的模型程序和数据存储器分开，但是复用总线（地址和数据）

通用处理器GPP
数字信号处理器DSP
硬件乘法器
卷积，数字滤波，FFT，矩阵运算
浮点DSP硬件浮点运算
专用处理器ASP及ASIC

CFI
SRAM NOR
片上执行
NAND只可块操作，专用接口

对于NOR，NAND等提供了MTD子系统，其上运行的YFSS2，JFFS3，UBIFS等具备擦出和负载均衡能力的文件系统

外设接口
RS232 RS485
I2C SPI CAN
USB SDIO LAN
EMMC I3C MIPI

linux2.6内核
调度器CFS算法EDF算法
内核抢占，线程模型NPTL
虚拟内存 反向映射
文件系统 btrfs
总线、设备、驱动模型

驱动drivers与arch独立，kernel fs ipc net等与硬件剥离
进程调度 内存管理 VFS net IPC
进程调度 CFS算法EDF算法
内存管理buddy算法slab flusher kswapd
VFS 为各个不同文件系统封装为统一接口，还有利用net的NFS，利用mm的ramdisk
NET
IPC 信号量，共享内存，消息队列，管道，UNIX域套接字

早期bootloader以ATAG格式形式封装启动信息，把其地址放入r2寄存器，linux支持设备树后，bootloader把dtb地址放入r2，可以通过配置把dtb和zImage绑定，r2不需要放dtb地址了
bootrom--bootloader--linux--init运行并生成进程树
arm-linux-guneabihf-gcc使用硬件浮点FPU处理浮点数比arm-linux-guneabi-gcc编译的程序处理浮点数运算的性能好得多

驱动模块
insmod modprobe加载模块，rmmod卸载模块
驱动程序中使用request_module(module_name)加载模块
声明时加_init的函数和声明时加_initdata的变量将在初始化完成后释放内存空间
模块卸载函数和变量中加_exit _exitdata表示如果模块直接编译进内核时，这些变量和函数将被忽略，因为不会使用卸载函数
module_param()用于从insmod modprobe参数中获取参数，当编译进内核时，可以从bootargs获取
/proc/kallsyms存放内核符号表及其地址，导出的符号可以被其他模块使用，声明一下即可EXPORT_SYMBOL,EXPORT_SYMBOL_GPL到处的符号表不能被非GPL的模块引用
MODULE_LISENCE,为了使用GPL的符号表，非GPL的模块经常把GPL的符号表封装一层使用EXPORT_SYMBOL导出
作者MODULE_AUTHOR，描述MODULE_DESCRIPTION，版本MODULE_VERSION，设备表MODULE_DEVICE_TABLE，别名MODULE_ALIAS
SMP和PREEMPT
模块计数用于管理模块是否被使用，被使用时无法卸载模块
linux文件操作creat umask open read write lseek close
c库文件操作fopen fgetc fputc fgets fputs fprintf fscanf fread fwrite fgetpos fsetpos fseek fclose
fread如果返回值不等与字段数，可能时出错或者文件末尾，需要调用feof或ferror查看
VFS与应用之间的接口是以上系统调用，与内核接口是file_operations
目录/proc目录存放进程及内核信息，这个目录并不是真正的文件，他存在于内存中，/sys目录存放sysfs，虚拟的，linux设备驱动模型中的总线驱动和设备都有节点，总线设备类
文件file结构体和inode结构体
linux2.6以后udev取代devfs
注册和注销字符设备register_chrdev,unregister_chrdev
linux设计的一个基本观点是机制和策略分离，机制是做事情的步骤方法，是固定的，策略是每个步骤的具体实现，是不固定的，因此linux内核中不应实现策略
udev完全在用户态工作，发送的事件uevent
总线bus_type,驱动device_driver,设备device结构体
设备和驱动都依附于总线，因此设备和驱动结构体中都有总线的实例，设备和驱动分离，通过总线match函数检测到匹配的设备和驱动时，才执行驱动的probe函数，
总线有platform，pci，i2c，usb等，总线设备驱动最终落实在sysfs，attribute落实为sysfs中的一个文件
udev动态建立删除设备文件，内核检测到设备后，会使用netlink发送uevent，udev通过内核发送的内容进行匹配，例如插入u盘，udev规则文件定义新设备处理规则
udevadm info -a -p /sys/device/platform/serial8250/tty/ttyS0
udev的轻量级版本mdev

字符设备驱动：cdev结构体
cdev_init建立设备和file_operation产生联系
cdev_alloc开辟cdev空间
cdev_add,cdev_dev设备添加和删除
register_chrdev_region申请设备号
alloc_chrdev_region申请设备号，设备号起始地址未知
unregister_chrdev_region释放设备号

file_operation结构体
llseek read write（read write返回0表示EOF）
unlocked_ioctl和用户空间fcntl和ioctl对应
mmap将设备内存映射到进程的虚拟地址空间，帧缓冲驱动中使用其直接修改显示内容
open release
poll和用户空间的poll和select对应
aio_read aio_write异步读写，对应用户空间SYS_io_setup,SYS_io_submit,SYS_io_getevents,SYS_io_destroy
用户空间不能访问内核空间内存，使用copy_from_user,copy_to_user转换
内核空间可以访问用户空间内存，使用access_ok检查是否是用户空间内存，如果不检查，入侵者可以传入一个内核空间地址，让驱动给其填充数据

ioctl的参数cmd
设备类型（魔数），序列号，方向，长度，使用_IO() _IOR() _IOW() _IOWR()四个宏定义生成cmd，内核中有一些专用的控制命令无法被驱动使用
设备驱动中常把私有数据private_data指向设备结构体，再用read write ioctl lseek访问private_data
private_data的设置可以在open函数中
使用private_data的好处是可以轻易的修改为支持多个同类设备的驱动
container_of是通过成员指针获取结构体指针

加载模块，创建节点mknod
字符驱动 初始化，添加删除cdev结构体，申请释放设备号，填充file_operations函数

并发和竞态
并发：多个执行单元同时并行运行
竞态：同时并行运行的执行单元访问共享资源（硬件，软件上的全局变量和静态变量）
进程和进程间（多处理器和单处理器时间片），进程和中断间，中断和中断间（中断嵌套，2.6.35之后取消了中断嵌套，之前可以用IRQF_DISABLE避免嵌套）
解决竞态的办法是互斥访问共享资源，访问共享资源的代码区域叫做临界区，临界区需要互斥机制保护（中断屏蔽，原子操作，自旋锁，信号量，互斥体）

编译乱序和执行乱序
编译乱序：打开编译器优化后，编译器会对访存指令乱序提高cache命中率，可以使用barrier编译屏障防止编译乱序，barrier可以保证其之前和之后的程序不乱序
volatile也具有防止编译乱序的弱作用，比如线程两次访问某变量，如果不加volatile，可能第二次会直接优化掉使用第一次的结果，volatile不能保护临界资源
linux内核中不太喜欢volatile
执行乱序：当一条指令访存时间较长时，如果后面的指令不依赖于前面的执行结构，可能会同时执行后面指令，ARM926EJ-S没有执行乱序功能，新核有
可以使用内存屏障解决执行乱序造成的问题，当访问外设寄存器时，这些外设寄存器对CPU逻辑上无法构成以来，可能会出现内存乱序，当这些寄存器的访问需要顺序
执行时，需要使用内存屏障DMB,DSB,ISB，读写寄存器readl,readl_relaxed, writel,writel_relaxed,前边的有内存屏障，后边的没有
当开启dma时，先使用writel_relaxed写入地址大小等，在使用writel是能dma，防止乱序造成先是能dma后配置

中断屏蔽：单片机等单核cpu中常在进入临界区前屏蔽中断解决竞态问题，linux内核驱动为了保证可以执行一般不这样做
local_irq_disable,local_irq_enable,中断屏蔽实际是解决进程和中断间的竞态，而linux的进程调度也是以来中断实现，因此也解决了进程和进程间的竞态，
但是只能屏蔽本cpu的中断，在不能解决SMP中的竞态，应与自旋锁联合使用

原子操作：在arm中使用LDREX,STREX指令实现，实现单cpu和多cpu的原子操作
linux中有整形原子操作atomic_set,atomic_read,atomic_add,atomic_sub,atomic_inc,atomic_dec,
位原子操作set_bit,clear_bit,change_bit,test_bit

自旋锁：获取自旋锁是一个原子操作，当锁被获取后，如果其他执行单元需要获取锁，则一直判断锁是否被释放，直到其被释放，自旋锁持有期间内核抢占被禁止，
SMP中只有当前核的抢占被禁止。
spinlock_t lock;spin_lock_init(lock);spin_lock(lock);spin_trylock(lock)实际不自旋;spin_unlock(lock);
自旋锁虽然不会被进程调度影响，但是会被中断和底半部影响，因此需要配合关中断local_irq_disable，关底半部local_bh_disable,关中断并保存状态local_irq_save使用
形成了spin_lock_irq,spin_unlock_irq;spin_lock_irqsave,spin_unlock_irqrestore;spin_lock_bh,spin_unlock_bh;
进程中使用spin_lock_irqsave,中断中使用spin_lock,这样进程cpu核的中断核抢占被禁止，而其他核获取spin_lock会失败
使用自旋锁的注意事项1自旋锁是死等，适用于临界区较短，不适用于临界区大或者有共享设备时2死锁，当一个进程获取自旋锁后再次获取3获取自旋锁后不能调用
copy_to_user,copy_from_user,kmalloc,msleep等可以导致阻塞的函数4中断里使用spin_lock防止多处理器时，中断在其他核运行
使用自旋锁使设备只能被一个进程打开，在open核release函数中使用自旋锁判断使用计数
读写自旋锁：rwlock_t lock;rwlock_init(lock),read_lock(),read_lock_irqsave,read_lock_irq,read_lock_bh,read_unlock(),写锁一样，与自旋锁使用方法相同
多读单写，读写不能同时
顺序锁：write_seqlock,write_tryseqlock,write_seqlock_irqsave,write_seqlock_irq,write_seqlock_bh,write_sequnlock
read_seqbegin,read_seqbegin_irqsave,配合read_seqretry,read_seqretry_irqrestore使用，如果读过程中被写，会执行重读
多读单写，读写同时进行，读时如果写，则循环重读
RCU锁：读复制更新锁，读不需要加锁，写是先读，然后拷贝到一个副本，修改副本后，等所有处理器不在引用数据时，更新回原数据
rcu_read_lock,rcu_read_unlock,synchronize_rcu(),call_rcu,rcu_assign_pointer,rcu_dereference,rcu_access_pointer以及操作链表的函数
读写同时，读效率高，写效率低，不适用与写入频繁的操作;
信号量：P获取信号量，V释放信号量sem_init(),down()会导致睡眠，不能在中断里使用，睡眠中不能被信号打断，down_interruptible可以被信号打断
down_trylock(),up()释放信号量，信号量在获取不到时会睡眠，而自旋锁获取不到会等待，信号量常用于解决生产者消费者问题，信号量内核中多被mutex取代
互斥体：mutex_init()，mutex_lock()导致睡眠不能打断,mutex_trylock(),mutex_lock_interruptible()，mutex_unlock()
自旋锁和互斥体运用最广泛
1互斥体是进程级的，适用于临界区较大的情况，自旋锁适用于临界区小的情况
2互斥体保护的临界区可以有引起阻塞的代码，但是自旋锁不行，可能导致死锁
3如果是在中断里，只能使用自旋锁，当然也可用mutex_trylock()
完成量：一个执行单元等待另一个执行单元完成某事init_completion(),wait_for_completion(),complete(),complete_all();

阻塞与非阻塞IO
open使用O_NONBLOCK参数时为非阻塞，或者使用fcntl设置，否则为阻塞
使用等待队列实现阻塞IO，init_waitqueue_head(),add_wait_queue(),remove_wait_queue();
wait_event(),wait_event_interruptible(),wait_event_timeout(),wait_event_interruptible_timeout(),interruptible表示可被信号打断，timeout表示可超时退出
wake_up(),唤醒处于可打断和不可打断的进程，wake_up_interruptible()打断可被信号打断的进程与wait_函数对应使用
sleep_on(),interruptible_sleep_on()把进程状态设置为TASK_UNINTERRUPTIBLE和TASK_INTERRUPTIBLE







